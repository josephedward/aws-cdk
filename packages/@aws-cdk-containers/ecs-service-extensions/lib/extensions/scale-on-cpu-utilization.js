"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScaleOnCpuUtilization = void 0;
const cdk = require("@aws-cdk/core");
const extension_interfaces_1 = require("./extension-interfaces");
// The default autoscaling settings
const cpuScalingPropsDefault = {
    initialTaskCount: 2,
    minTaskCount: 2,
    maxTaskCount: 8,
    targetCpuUtilization: 50,
    scaleOutCooldown: cdk.Duration.seconds(60),
    scaleInCooldown: cdk.Duration.seconds(60),
};
/**
 * This extension helps you scale your service according to CPU utilization.
 *
 * @deprecated To enable target tracking based on CPU utilization, use the `targetCpuUtilization` property of `autoScaleTaskCount` in the `Service` construct.
 * For more information, please refer https://github.com/aws/aws-cdk/blob/main/packages/%40aws-cdk-containers/ecs-service-extensions/README.md#task-auto-scaling .
 */
class ScaleOnCpuUtilization extends extension_interfaces_1.ServiceExtension {
    constructor(props) {
        super('scale-on-cpu-utilization');
        let combinedProps = {
            ...cpuScalingPropsDefault,
            ...props,
        };
        this.initialTaskCount = combinedProps.initialTaskCount;
        this.minTaskCount = combinedProps.minTaskCount;
        this.maxTaskCount = combinedProps.maxTaskCount;
        this.targetCpuUtilization = combinedProps.targetCpuUtilization;
        this.scaleOutCooldown = combinedProps.scaleOutCooldown;
        this.scaleInCooldown = combinedProps.scaleInCooldown;
    }
    // This service modifies properties of the service prior
    // to construct creation.
    modifyServiceProps(props) {
        return {
            ...props,
            // Launch an initial number of tasks
            // In the future we should change this to use a custom resource
            // to read the current task count set by autoscaling, so that the task
            // count doesn't rollback to the initial level on each deploy.
            desiredCount: this.initialTaskCount,
        };
    }
    // This hook utilizes the resulting service construct
    // once it is created.
    useService(service) {
        if (this.parentService.scalableTaskCount) {
            throw Error('Cannot specify \'autoScaleTaskCount\' in the Service construct and also provide a  \'ScaleOnCpuUtilization\' extension. \'ScaleOnCpuUtilization\' is deprecated. Please only provide \'autoScaleTaskCount\'.');
        }
        const scalingTarget = service.autoScaleTaskCount({
            minCapacity: this.minTaskCount,
            maxCapacity: this.maxTaskCount,
        });
        scalingTarget.scaleOnCpuUtilization(`${this.parentService.id}-target-cpu-utilization-${this.targetCpuUtilization}`, {
            targetUtilizationPercent: this.targetCpuUtilization,
            scaleInCooldown: this.scaleInCooldown,
            scaleOutCooldown: this.scaleOutCooldown,
        });
        this.parentService.enableAutoScalingPolicy();
    }
}
exports.ScaleOnCpuUtilization = ScaleOnCpuUtilization;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhbGUtb24tY3B1LXV0aWxpemF0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2NhbGUtb24tY3B1LXV0aWxpemF0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLHFDQUFxQztBQUNyQyxpRUFBd0U7QUFzRHhFLG1DQUFtQztBQUNuQyxNQUFNLHNCQUFzQixHQUFHO0lBQzdCLGdCQUFnQixFQUFFLENBQUM7SUFDbkIsWUFBWSxFQUFFLENBQUM7SUFDZixZQUFZLEVBQUUsQ0FBQztJQUNmLG9CQUFvQixFQUFFLEVBQUU7SUFDeEIsZ0JBQWdCLEVBQUUsR0FBRyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDO0lBQzFDLGVBQWUsRUFBRSxHQUFHLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7Q0FDMUMsQ0FBQztBQUVGOzs7OztHQUtHO0FBQ0gsTUFBYSxxQkFBc0IsU0FBUSx1Q0FBZ0I7SUErQnpELFlBQVksS0FBdUI7UUFDakMsS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUM7UUFFbEMsSUFBSSxhQUFhLEdBQUc7WUFDbEIsR0FBRyxzQkFBc0I7WUFDekIsR0FBRyxLQUFLO1NBQ1QsQ0FBQztRQUVGLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxhQUFhLENBQUMsZ0JBQWdCLENBQUM7UUFDdkQsSUFBSSxDQUFDLFlBQVksR0FBRyxhQUFhLENBQUMsWUFBWSxDQUFDO1FBQy9DLElBQUksQ0FBQyxZQUFZLEdBQUcsYUFBYSxDQUFDLFlBQVksQ0FBQztRQUMvQyxJQUFJLENBQUMsb0JBQW9CLEdBQUcsYUFBYSxDQUFDLG9CQUFvQixDQUFDO1FBQy9ELElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxhQUFhLENBQUMsZ0JBQWdCLENBQUM7UUFDdkQsSUFBSSxDQUFDLGVBQWUsR0FBRyxhQUFhLENBQUMsZUFBZSxDQUFDO0lBQ3ZELENBQUM7SUFFRCx3REFBd0Q7SUFDeEQseUJBQXlCO0lBQ2xCLGtCQUFrQixDQUFDLEtBQW1CO1FBQzNDLE9BQU87WUFDTCxHQUFHLEtBQUs7WUFFUixvQ0FBb0M7WUFDcEMsK0RBQStEO1lBQy9ELHNFQUFzRTtZQUN0RSw4REFBOEQ7WUFDOUQsWUFBWSxFQUFFLElBQUksQ0FBQyxnQkFBZ0I7U0FDcEIsQ0FBQztJQUNwQixDQUFDO0lBRUQscURBQXFEO0lBQ3JELHNCQUFzQjtJQUNmLFVBQVUsQ0FBQyxPQUE0QztRQUM1RCxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsaUJBQWlCLEVBQUU7WUFDeEMsTUFBTSxLQUFLLENBQUMsOE1BQThNLENBQUMsQ0FBQztTQUM3TjtRQUNELE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQztZQUMvQyxXQUFXLEVBQUUsSUFBSSxDQUFDLFlBQVk7WUFDOUIsV0FBVyxFQUFFLElBQUksQ0FBQyxZQUFZO1NBQy9CLENBQUMsQ0FBQztRQUVILGFBQWEsQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSwyQkFBMkIsSUFBSSxDQUFDLG9CQUFvQixFQUFFLEVBQUU7WUFDbEgsd0JBQXdCLEVBQUUsSUFBSSxDQUFDLG9CQUFvQjtZQUNuRCxlQUFlLEVBQUUsSUFBSSxDQUFDLGVBQWU7WUFDckMsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLGdCQUFnQjtTQUN4QyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsYUFBYSxDQUFDLHVCQUF1QixFQUFFLENBQUM7SUFDL0MsQ0FBQztDQUNGO0FBL0VELHNEQStFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGVjcyBmcm9tICdAYXdzLWNkay9hd3MtZWNzJztcbmltcG9ydCAqIGFzIGNkayBmcm9tICdAYXdzLWNkay9jb3JlJztcbmltcG9ydCB7IFNlcnZpY2VFeHRlbnNpb24sIFNlcnZpY2VCdWlsZCB9IGZyb20gJy4vZXh0ZW5zaW9uLWludGVyZmFjZXMnO1xuXG5cbi8qKlxuICogVGhlIGF1dG9zY2FsaW5nIHNldHRpbmdzLlxuICpcbiAqIEBkZXByZWNhdGVkIHVzZSB0aGUgYG1pblRhc2tDb3VudGAgYW5kIGBtYXhUYXNrQ291bnRgIHByb3BlcnRpZXMgb2YgYGF1dG9TY2FsZVRhc2tDb3VudGAgaW4gdGhlIGBTZXJ2aWNlYCBjb25zdHJ1Y3RcbiAqIHRvIGNvbmZpZ3VyZSB0aGUgYXV0byBzY2FsaW5nIHRhcmdldCBmb3IgdGhlIHNlcnZpY2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBwbGVhc2UgcmVmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9ibG9iL21haW4vcGFja2FnZXMvJTQwYXdzLWNkay1jb250YWluZXJzL2Vjcy1zZXJ2aWNlLWV4dGVuc2lvbnMvUkVBRE1FLm1kI3Rhc2stYXV0by1zY2FsaW5nIC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDcHVTY2FsaW5nUHJvcHMge1xuICAvKipcbiAgICogSG93IG1hbnkgdGFza3MgdG8gbGF1bmNoIGluaXRpYWxseS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSAyXG4gICAqL1xuICByZWFkb25seSBpbml0aWFsVGFza0NvdW50PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBudW1iZXIgb2YgdGFza3Mgd2hlbiBzY2FsaW5nIGluLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIDJcbiAgICovXG4gIHJlYWRvbmx5IG1pblRhc2tDb3VudD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHRhc2tzIHdoZW4gc2NhbGluZyBvdXQuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gOFxuICAgKi9cbiAgcmVhZG9ubHkgbWF4VGFza0NvdW50PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgQ1BVIHV0aWxpemF0aW9uIHRvIHRyeSBvdCBtYWludGFpbi5cbiAgICpcbiAgICogQGRlZmF1bHQgLSA1MCVcbiAgICovXG4gIHJlYWRvbmx5IHRhcmdldENwdVV0aWxpemF0aW9uPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBIb3cgbG9uZyB0byB3YWl0IGJldHdlZW4gc2NhbGUgb3V0IGFjdGlvbnMuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gNjAgc2Vjb25kc1xuICAgKi9cbiAgcmVhZG9ubHkgc2NhbGVPdXRDb29sZG93bj86IGNkay5EdXJhdGlvbjtcblxuICAvKipcbiAgICogSG93IGxvbmcgdG8gd2FpdCBiZXR3ZWVuIHNjYWxlIGluIGFjdGlvbnMuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gNjAgc2Vjb25kc1xuICAgKi9cbiAgcmVhZG9ubHkgc2NhbGVJbkNvb2xkb3duPzogY2RrLkR1cmF0aW9uO1xufVxuXG4vLyBUaGUgZGVmYXVsdCBhdXRvc2NhbGluZyBzZXR0aW5nc1xuY29uc3QgY3B1U2NhbGluZ1Byb3BzRGVmYXVsdCA9IHtcbiAgaW5pdGlhbFRhc2tDb3VudDogMixcbiAgbWluVGFza0NvdW50OiAyLFxuICBtYXhUYXNrQ291bnQ6IDgsXG4gIHRhcmdldENwdVV0aWxpemF0aW9uOiA1MCxcbiAgc2NhbGVPdXRDb29sZG93bjogY2RrLkR1cmF0aW9uLnNlY29uZHMoNjApLFxuICBzY2FsZUluQ29vbGRvd246IGNkay5EdXJhdGlvbi5zZWNvbmRzKDYwKSxcbn07XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gaGVscHMgeW91IHNjYWxlIHlvdXIgc2VydmljZSBhY2NvcmRpbmcgdG8gQ1BVIHV0aWxpemF0aW9uLlxuICpcbiAqIEBkZXByZWNhdGVkIFRvIGVuYWJsZSB0YXJnZXQgdHJhY2tpbmcgYmFzZWQgb24gQ1BVIHV0aWxpemF0aW9uLCB1c2UgdGhlIGB0YXJnZXRDcHVVdGlsaXphdGlvbmAgcHJvcGVydHkgb2YgYGF1dG9TY2FsZVRhc2tDb3VudGAgaW4gdGhlIGBTZXJ2aWNlYCBjb25zdHJ1Y3QuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHJlZmVyIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9ibG9iL21haW4vcGFja2FnZXMvJTQwYXdzLWNkay1jb250YWluZXJzL2Vjcy1zZXJ2aWNlLWV4dGVuc2lvbnMvUkVBRE1FLm1kI3Rhc2stYXV0by1zY2FsaW5nIC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNjYWxlT25DcHVVdGlsaXphdGlvbiBleHRlbmRzIFNlcnZpY2VFeHRlbnNpb24ge1xuICAvKipcbiAgICogSG93IG1hbnkgdGFza3MgdG8gbGF1bmNoIGluaXRpYWxseS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBpbml0aWFsVGFza0NvdW50OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIG51bWJlciBvZiB0YXNrcyB3aGVuIHNjYWxpbmcgaW4uXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbWluVGFza0NvdW50OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0YXNrcyB3aGVuIHNjYWxpbmcgb3V0LlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IG1heFRhc2tDb3VudDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgQ1BVIHV0aWxpemF0aW9uIHRvIHRyeSBvdCBtYWludGFpbi5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSB0YXJnZXRDcHVVdGlsaXphdGlvbjogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBIb3cgbG9uZyB0byB3YWl0IGJldHdlZW4gc2NhbGUgb3V0IGFjdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgc2NhbGVPdXRDb29sZG93bjogY2RrLkR1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBIb3cgbG9uZyB0byB3YWl0IGJldHdlZW4gc2NhbGUgaW4gYWN0aW9ucy5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBzY2FsZUluQ29vbGRvd246IGNkay5EdXJhdGlvbjtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcz86IENwdVNjYWxpbmdQcm9wcykge1xuICAgIHN1cGVyKCdzY2FsZS1vbi1jcHUtdXRpbGl6YXRpb24nKTtcblxuICAgIGxldCBjb21iaW5lZFByb3BzID0ge1xuICAgICAgLi4uY3B1U2NhbGluZ1Byb3BzRGVmYXVsdCxcbiAgICAgIC4uLnByb3BzLFxuICAgIH07XG5cbiAgICB0aGlzLmluaXRpYWxUYXNrQ291bnQgPSBjb21iaW5lZFByb3BzLmluaXRpYWxUYXNrQ291bnQ7XG4gICAgdGhpcy5taW5UYXNrQ291bnQgPSBjb21iaW5lZFByb3BzLm1pblRhc2tDb3VudDtcbiAgICB0aGlzLm1heFRhc2tDb3VudCA9IGNvbWJpbmVkUHJvcHMubWF4VGFza0NvdW50O1xuICAgIHRoaXMudGFyZ2V0Q3B1VXRpbGl6YXRpb24gPSBjb21iaW5lZFByb3BzLnRhcmdldENwdVV0aWxpemF0aW9uO1xuICAgIHRoaXMuc2NhbGVPdXRDb29sZG93biA9IGNvbWJpbmVkUHJvcHMuc2NhbGVPdXRDb29sZG93bjtcbiAgICB0aGlzLnNjYWxlSW5Db29sZG93biA9IGNvbWJpbmVkUHJvcHMuc2NhbGVJbkNvb2xkb3duO1xuICB9XG5cbiAgLy8gVGhpcyBzZXJ2aWNlIG1vZGlmaWVzIHByb3BlcnRpZXMgb2YgdGhlIHNlcnZpY2UgcHJpb3JcbiAgLy8gdG8gY29uc3RydWN0IGNyZWF0aW9uLlxuICBwdWJsaWMgbW9kaWZ5U2VydmljZVByb3BzKHByb3BzOiBTZXJ2aWNlQnVpbGQpOiBTZXJ2aWNlQnVpbGQge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5wcm9wcyxcblxuICAgICAgLy8gTGF1bmNoIGFuIGluaXRpYWwgbnVtYmVyIG9mIHRhc2tzXG4gICAgICAvLyBJbiB0aGUgZnV0dXJlIHdlIHNob3VsZCBjaGFuZ2UgdGhpcyB0byB1c2UgYSBjdXN0b20gcmVzb3VyY2VcbiAgICAgIC8vIHRvIHJlYWQgdGhlIGN1cnJlbnQgdGFzayBjb3VudCBzZXQgYnkgYXV0b3NjYWxpbmcsIHNvIHRoYXQgdGhlIHRhc2tcbiAgICAgIC8vIGNvdW50IGRvZXNuJ3Qgcm9sbGJhY2sgdG8gdGhlIGluaXRpYWwgbGV2ZWwgb24gZWFjaCBkZXBsb3kuXG4gICAgICBkZXNpcmVkQ291bnQ6IHRoaXMuaW5pdGlhbFRhc2tDb3VudCxcbiAgICB9IGFzIFNlcnZpY2VCdWlsZDtcbiAgfVxuXG4gIC8vIFRoaXMgaG9vayB1dGlsaXplcyB0aGUgcmVzdWx0aW5nIHNlcnZpY2UgY29uc3RydWN0XG4gIC8vIG9uY2UgaXQgaXMgY3JlYXRlZC5cbiAgcHVibGljIHVzZVNlcnZpY2Uoc2VydmljZTogZWNzLkVjMlNlcnZpY2UgfCBlY3MuRmFyZ2F0ZVNlcnZpY2UpIHtcbiAgICBpZiAodGhpcy5wYXJlbnRTZXJ2aWNlLnNjYWxhYmxlVGFza0NvdW50KSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2Fubm90IHNwZWNpZnkgXFwnYXV0b1NjYWxlVGFza0NvdW50XFwnIGluIHRoZSBTZXJ2aWNlIGNvbnN0cnVjdCBhbmQgYWxzbyBwcm92aWRlIGEgIFxcJ1NjYWxlT25DcHVVdGlsaXphdGlvblxcJyBleHRlbnNpb24uIFxcJ1NjYWxlT25DcHVVdGlsaXphdGlvblxcJyBpcyBkZXByZWNhdGVkLiBQbGVhc2Ugb25seSBwcm92aWRlIFxcJ2F1dG9TY2FsZVRhc2tDb3VudFxcJy4nKTtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGluZ1RhcmdldCA9IHNlcnZpY2UuYXV0b1NjYWxlVGFza0NvdW50KHtcbiAgICAgIG1pbkNhcGFjaXR5OiB0aGlzLm1pblRhc2tDb3VudCxcbiAgICAgIG1heENhcGFjaXR5OiB0aGlzLm1heFRhc2tDb3VudCxcbiAgICB9KTtcblxuICAgIHNjYWxpbmdUYXJnZXQuc2NhbGVPbkNwdVV0aWxpemF0aW9uKGAke3RoaXMucGFyZW50U2VydmljZS5pZH0tdGFyZ2V0LWNwdS11dGlsaXphdGlvbi0ke3RoaXMudGFyZ2V0Q3B1VXRpbGl6YXRpb259YCwge1xuICAgICAgdGFyZ2V0VXRpbGl6YXRpb25QZXJjZW50OiB0aGlzLnRhcmdldENwdVV0aWxpemF0aW9uLFxuICAgICAgc2NhbGVJbkNvb2xkb3duOiB0aGlzLnNjYWxlSW5Db29sZG93bixcbiAgICAgIHNjYWxlT3V0Q29vbGRvd246IHRoaXMuc2NhbGVPdXRDb29sZG93bixcbiAgICB9KTtcbiAgICB0aGlzLnBhcmVudFNlcnZpY2UuZW5hYmxlQXV0b1NjYWxpbmdQb2xpY3koKTtcbiAgfVxufVxuIl19